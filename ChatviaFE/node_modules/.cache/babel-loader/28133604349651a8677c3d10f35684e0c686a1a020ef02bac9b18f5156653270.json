{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform, sendMessage } from \"./Utils\";\n/** @private */\nexport class ServerSentEventsTransport {\n  constructor(httpClient, accessToken, logger, options) {\n    this._httpClient = httpClient;\n    this._accessToken = accessToken;\n    this._logger = logger;\n    this._options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  async connect(url, transferFormat) {\n    Arg.isRequired(url, \"url\");\n    Arg.isRequired(transferFormat, \"transferFormat\");\n    Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n    this._logger.log(LogLevel.Trace, \"(SSE transport) Connecting.\");\n    // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\n    this._url = url;\n    if (this._accessToken) {\n      url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\n    }\n    return new Promise((resolve, reject) => {\n      let opened = false;\n      if (transferFormat !== TransferFormat.Text) {\n        reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n        return;\n      }\n      let eventSource;\n      if (Platform.isBrowser || Platform.isWebWorker) {\n        eventSource = new this._options.EventSource(url, {\n          withCredentials: this._options.withCredentials\n        });\n      } else {\n        // Non-browser passes cookies via the dictionary\n        const cookies = this._httpClient.getCookieString(url);\n        const headers = {};\n        headers.Cookie = cookies;\n        const [name, value] = getUserAgentHeader();\n        headers[name] = value;\n        eventSource = new this._options.EventSource(url, {\n          withCredentials: this._options.withCredentials,\n          headers: {\n            ...headers,\n            ...this._options.headers\n          }\n        });\n      }\n      try {\n        eventSource.onmessage = e => {\n          if (this.onreceive) {\n            try {\n              this._logger.log(LogLevel.Trace, `(SSE transport) data received. ${getDataDetail(e.data, this._options.logMessageContent)}.`);\n              this.onreceive(e.data);\n            } catch (error) {\n              this._close(error);\n              return;\n            }\n          }\n        };\n        // @ts-ignore: not using event on purpose\n        eventSource.onerror = e => {\n          // EventSource doesn't give any useful information about server side closes.\n          if (opened) {\n            this._close();\n          } else {\n            reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\" + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\" + \" If you have multiple servers check that sticky sessions are enabled.\"));\n          }\n        };\n        eventSource.onopen = () => {\n          this._logger.log(LogLevel.Information, `SSE connected to ${this._url}`);\n          this._eventSource = eventSource;\n          opened = true;\n          resolve();\n        };\n      } catch (e) {\n        reject(e);\n        return;\n      }\n    });\n  }\n  async send(data) {\n    if (!this._eventSource) {\n      return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n    }\n    return sendMessage(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\n  }\n  stop() {\n    this._close();\n    return Promise.resolve();\n  }\n  _close(e) {\n    if (this._eventSource) {\n      this._eventSource.close();\n      this._eventSource = undefined;\n      if (this.onclose) {\n        this.onclose(e);\n      }\n    }\n  }\n}\n//# sourceMappingURL=ServerSentEventsTransport.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}